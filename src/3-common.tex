\section{A Core Language}
\label{sec:language}

This section lays the groundwork for the rest of the technical content of this dissertation: we present our core programmming language for distributed streaming applications. The language is built over a type system for streams called \emph{synchronization schemas}~\citeMain{pods21}, which evolved from earlier work on \emph{data-trace types}~\citeMain{festschrift18,pldi19}. a library of high-level language constructs over typed streams called \emph{SQREL}, and composition rules for composing language constructs.

\subsection{Synchronization Schemas}

We argue that streams should be viewed as \emph{partially ordered},
and ordering requirements should be defined by using
\emph{types} to describe these partial orders on concrete streams.

Why ``schemas''? A table in a database is typically defined using a \emph{relational schema}, which defines the type of items (tuples) in the relation. By analogy, a stream in a stream processing system can be defined by a synchronization schema, which defines the type of items in the stream \emph{in addition to} a binary relation between items called \emph{synchronizes}: ``$a$ synchronizes $b$'' means that $a$ and $b$ are comparable in the partial order ($a < b$ or $b < a$), subject to an additional restriction that if both $a$ and $a'$ synchronize $b$, then $a$ and $a'$ are also comparable ($a < a'$ or $a' < a$).
% TBD
We first formalize this idea, as it is the crux of what a synchronization schema denotes.

\begin{definition}
Let $D$ be a set of data items. A \emph{synchronization relation} on $D$ is a binary relation $\preceq$ subject to three conditions:
\begin{enumerate}[(1)]
\item Transitivity: if $a \preceq b$ and $b \preceq c$ then $a \preceq c$.
\item If $a \preceq b$ and $a' \preceq b$, then either $a \preceq a'$ or $a' \preceq a$.
\end{enumerate}
\end{definition}

\begin{definition}
Let $T$ denote a base type in the following grammar. A \emph{synchronization schema} is a type defined syntactically by the following grammar:
\[    S \ ::=\   \relleaf{T} \mid
             \hier{T}{S} \mid
            \keyby{T}{S} \mid
             \parcomp{S}{S}.
\]
% \begin{align*}
% S ::=
%   & Synch(T, S) \\
%   & Par(S, S) \\
%   & Empty
%   &
% \end{align*}
\end{definition}
