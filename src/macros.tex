%%% Macros for dissertation proposal + dissertation
%%% Caleb Stanford
%%% January 2021 -- Present

%% Text macros
\newcommand{\naive}{naïve}
\newcommand{\Naive}{Naïve}

%% Fonts
% For traces
\newcommand{\trc}[1]{\mathbf{#1}}
% For tags / alphabet symbols
\newcommand{\tg}[1]{\texttt{#1}}
% For data words
\newcommand{\dw}[1]{\textbf{#1}}
% For data vectors
\newcommand{\dv}[1]{\textbf{#1}}
% For an automaton
\newcommand{\aut}[1]{\mathcal{#1}}

%% Synchronization Schemas paper
\newcommand{\hdrfield}[2]{\left\langle#1: #2\right\rangle}
% Example schema
\renewcommand{\ss}{\ensuremath{{S}}}
% Schema recursive definition cases
\newcommand{\parcomp}[2]{\ensuremath{\mathsf{Par}({#1}, {#2})}}
\newcommand{\hier}[2]{\ensuremath{\mathsf{Sync}({#1}, #2)}}
\newcommand{\keyby}[2]{\ensuremath{\mathsf{ParBy}({#1}, #2)}}
\newcommand{\empstream}{\ensuremath{\mathsf{Emp}}}
\newcommand{\singleton}[1]{\ensuremath{\mathsf{Single}(#1)}}
\newcommand{\unittype}{\ensuremath{\bullet}}
% Derived
\newcommand{\parthree}[3]{\ensuremath{\mathsf{Par}({#1}, {#2}, {#3})}}
\newcommand{\seqleaf}[1]{\ensuremath{\mathsf{Seq}({#1})}}
\newcommand{\relleaf}[1]{\ensuremath{\mathsf{Bag}({#1})}}

%% Stream types
% View of streams 1: batches
\newcommand{\batchtype}[2]{\ensuremath{#1: \mathsf{Batch}({#2})}}
% View of streams 2: events and dep relation
\newcommand{\eventtype}[2]{\ensuremath{#1: \mathsf{Event}({#2})}}
\newcommand{\event}[1]{\mathsf{Event}(#1)}
\newcommand{\deptype}[3]{\ensuremath{#1 \,\mathcal{D}\, #2 \mod {#3}}}
\newcommand{\indeptype}[3]{\ensuremath{#1 \,\mathcal{I}\, #2 \mod {#3}}}
% View of streams 3: linearizations and equivalence relation
\newcommand{\lintype}[2]{\ensuremath{#1: \mathsf{Lin}({#2})}}
\newcommand{\equivtype}[3]{\ensuremath{#1 \equiv #2 \mod {#3}}}
% View of streams 4: labeled poset
\newcommand{\posettype}[2]{\ensuremath{#1: \mathsf{Pos}({#2})}}

\newcommand{\lininterleave}[2]{\ensuremath{\mathsf{inter}(#1; #2)}}
\newcommand{\parselin}[1]{\ensuremath{\mathsf{parse}(#1)}}

% Set of headers for a schema
\newcommand{\headers}{\ensuremath{\mathbf{headers}}}
\newcommand{\prefix}{\preceq}
%% Sec. 2 Series-Parallel Streams
\newcommand{\keyed}[2]{\ensuremath{{#1}\mapsto{#2}}}
\newcommand{\spstype}[2]{\ensuremath{#2[#1]}}
\newcommand{\spsseq}[1]{[#1]}
\newcommand{\spsbag}[1]{\{#1\}}
\newcommand{\spsbagleft}{\{\;} % for splitting across lines
\newcommand{\spsbagright}{\;\}} % for splitting across lines
\newcommand{\spspargen}[1]{\langle #1 \rangle}
\newcommand{\spspar}[2]{\spspargen{#1, #2}}
\newcommand{\spsemp}{\bot}
\newcommand{\tuprestrict}[2]{\ensuremath{{#1}|_{#2}}}
% For schema diagram
\newcommand{\TopSchemaNode}[1]{#1}
\newcommand{\SchemaNode}[2]{node (#2) { \TopSchemaNode{#1} } }
% The KeyBy Node takes 4 arguments:
% 1. The keys
% 2. The node name
% 3. The top node child of the KeyBy Node
% 4. The leaf of the KeyBy Node (to fit around it)
\newcommand{\KeyByNode}[4]{
    \node (#2) [above=1mm of #3.north west, draw=none] {#1};
    \node [draw=black!50, fit={(#3) (#4) (#2)}, double, rounded corners=0] (#2') {}
}
%% Sec. 3 Semantics
% tuples of a header, as a set
\newcommand{\tup}{\mathbf{tup}}
% SPSs of a given type, as a set
\newcommand{\sps}{\ensuremath{\mathbf{sps}}}
% bag of values
\newcommand{\bag}{\mathbf{bag}}
% notation for SPST components
\newcommand{\spstfield}[2]{{#1}.{\mathsf{#2}}}
% semantics for SPST:
% - closed semantics
% - open semantics
% - internal auxiliary semantics (only used in hierarchical case)
\newcommand{\spstsemC}[3]{\llbracket #3 \rrbracket_C (#1, #2)}
\newcommand{\spstsemO}[3]{\llbracket #3 \rrbracket_O (#1, #2)}
\newcommand{\spstsemI}[3]{\llbracket #3 \rrbracket_{Aux} (#1, #2)}
% big-step semantics for SPSQuery
\newcommand{\spsqsem}[3]{#1 \overset{#2}{\rightsquigarrow} #3}

%% Dependence relations from Data-trace types paper
\newcommand{\eq}{\equiv}
\newcommand{\dep}{\ensuremath{\mathrel{\mathrm{D}}}}

%% Static types from Data-trace types paper
% Unit type
\newcommand{\Ut}{\mathtt{Ut}}
% Natural numbers type
\newcommand{\Nat}{\mathbb{N}}
% Bag type
\newcommand{\Bag}{{\textstyle\mathop{\mathsf{Bag}}}}
% The main ones actually used to define graphs
\newcommand{\Ord}{\mathsf{O}}
\newcommand{\Unord}{\mathsf{U}}

%% Data Transducers
% DT elements
\newcommand{\states}{Q}
\newcommand{\tags}{\Sigma}
\newcommand{\update}{\Delta}
\newcommand{\init}{I}
\newcommand{\final}{F}
% To get the entire tuple (so order is tweakable):
\newcommand{\DTtuple}{(\states, \tags, \update, \init, \final)}
\newcommand{\DTtuplesub}[1]{(\states_{#1}, \tags, \update_{#1}, \init_{#1}, \final_{#1})}
\newcommand{\DT}{\aut{A}} % generic name of a data transducer
% \newcommand{\DTI}{\aut{I}} % name for data transducer which is the identity with a certain language.
\newcommand{\size}[1]{\mathsf{size}(#1)} % Size of a DT
\newcommand{\curritem}{\mathsf{cur}} % current data item
% Language and extended language
\newcommand{\lang}{L}
\newcommand{\clang}{\overline{\lang}}
% Signature elements
\newcommand{\data}{\mathbb{D}}
\newcommand{\ops}{\textsf{Op}} % operations
\newcommand{\tms}{\textsf{Tm}} % terms
\newcommand{\cdata}{\overline{\data{}}}
% Unit signature
\newcommand{\UU}{\mathbb{U}}
\newcommand{\cUU}{\overline{\UU}}
\newcommand{\one}{\star} % The middle element of the 3-element
                         % semiring, together with \bot and \top.
                         % The unique element of the unit signature.
\newcommand{\Uops}{\textsf{UOp}}
\newcommand{\uop}{o} % Unique k-ary unit map
\newcommand{\cUops}{\overline{\Uops{}}}
% Constructions
\newcommand{\parcompDT}[2]{#1 \; \| \; #2} % parallel composition combinator
\newcommand{\combine}[2]{#2(#1)}
\newcommand{\union}[2]{#1 \sqcup #2}
\newcommand{\prefixsum}[2]{\mathlarger{\oplus}_{#2} #1}
\newcommand{\isbot}[1]{[#1 = \bot]}
\newcommand{\isdef}[1]{[#1 \in \data]}
\newcommand{\istop}[1]{[#1 = \top]}
\newcommand{\concat}[2]{#1 \cdot #2}
\newcommand{\iter}[1]{{{#1}^{*}}}
% Constructions auxiliary
\newcommand{\DF}{G} % Data function
\newcommand{\DTtype}[2]{#1 \twoheadrightarrow #2} % Type of a DT
% \newcommand{\DTtype}[2]{#1 \Rightarrow\hspace{-2ex}\Rightarrow #2}
\newcommand{\DFtype}[2]{#1 \Rightarrow #2} % Type of a Data function
% QRE-Past
\newcommand{\QREpast}{\textsc{QRE-Past}}
\newcommand{\qq}{\alpha} % quantitative query
\newcommand{\tlqq}{\beta} % top-level quantitative query
\newcommand{\tq}{\varphi} % temporal query
\newcommand{\atomQ}{\texttt{atom}}
\newcommand{\epsQ}{\texttt{eps}}
\newcommand{\orQ}{\texttt{or}}
\newcommand{\splitQ}{\texttt{split}}
\newcommand{\iterQ}{\texttt{iter}}
\newcommand{\combineQ}{\texttt{combine}}
\newcommand{\prefsumQ}{\texttt{prefix-sum}}
\newcommand{\fillQ}{\texttt{fill}}
\newcommand{\fillwithQ}{\texttt{fill-with}}
% Temporal operators
\newcommand{\prevT}{\odot}
\newcommand{\alwaysT}{\boxdot}
\newcommand{\eventuallyT}{\;\cdot\hspace{-0.52em}\Diamond}
\newcommand{\sinceST}{\mathbin{\mathcal{S}_s}}
\newcommand{\sinceWT}{\mathbin{\mathcal{S}_w}}
% Specific operation
\newcommand{\op}{\mathit{op}}
\newcommand{\initval}{\mathit{init}}
\newcommand{\bop}{\mathbin{\mathit{bop}}} % boolean op
\newcommand{\compop}{\mathbin{\mathit{comp}}} % comparison op

%% Flumina DGS macros
% Wire diagram abbreviations
% \newcommand{\tg}[1]{\texttt{#1}} % For example event tags
\newcommand{\istate}{\texttt{init}}
\newcommand{\fk}{\texttt{f}}
\newcommand{\jn}{\texttt{j}}
% fst/snd functions and empty list, to be used inside \fl code
\newcommand{\fst}[1]{\fl{fst(}{#1}\fl{)}}
% Semantics of the model
\newcommand{\wire}[3]{\ensuremath{\langle #1, #2, #3 \rangle}}
\newcommand{\semantics}[6]{\wire{#1}{#2}{#3} \ensuremath{\underset{#6}{\overset{#4}{\longrightarrow}}} \wire{#1}{#2}{#5}}

%% Misc General
\newcommand{\pto}{\rightharpoonup} % partial function arrow
\newcommand{\sem}[1]{\llbracket #1 \rrbracket} % semantics
