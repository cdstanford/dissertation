\section{Syntax and Semantics}

This section lays the groundwork for the rest of the technical content of this dissertation: we present our core programmming language for distributed streaming applications. The language is built over a type system for streams called \emph{synchronization schemas}~\citeMain{pods21}, which evolved from earlier work on \emph{data-trace types}~\citeMain{festschrift18,pldi19}. a library of high-level language constructs over typed streams called \emph{SQREL}, and composition rules for composing language constructs.
% dummy citation to please bibtex -- TODO remove
\cite{StreamQRE}

\subsection{Syntax}

\subsubsection{Stream Types}

This definition differs from the stream types in \citeMain{pods21} in a few ways: (1) we don't assume the base types of events are headers (tuples); (2) the synchronization markers are elements of a single base type, not a set of headers; (3) we add the empty stream case, the singleton case, and the add-field case.

\begin{definition}
Let $T$ denote a base type in the following grammar.
A \emph{stream type} is a type defined syntactically by the following grammar:
\[
  S \quad ::= \quad
    \hier{T}{S} \mid
    \parcomp{S}{S} \mid
    \keyby{T}{S} \mid
    \singleton{T} \mid
    \empstream{}
\]
\end{definition}

We also have the following abbreviations:
\[
  \relleaf{T} := \keyby{T}{\singleton{\unittype{}}}
\]
where $\unittype{}$ denotes the unit type, and
\[
  \seqleaf{T} := \hier{T}{\empstream{}}.
\]

\subsubsection{Batches}

The following syntax defines concrete stream instances for each of the
stream types.
These are ``batch'' data.
To define a concrete stream instance, one either defines a pair, a sequence, or a bag (unordered set).
\[
  B \quad ::= \quad
    (B, B) \mid
    [B, B, \ldots, B] \mid
    \{B, B, \ldots, B\} \mid
    t: T
\]

These are typed using the following typing rules:

\begin{mathpar}
    \inference[Synchronization]
    {
      t_i: T \\
      b_i: S
    }
    {
      [b_0, t_1, b_1, t_2, b_2, \ldots, t_m, b_m]: \hier{T}{S}
    }

    \\

    \inference[PartitionBy]
    {
      t_i: T \\
      t_i \ne t_j \text{ for } i \ne j \\
      b_i: S
    }
    {
      \{(t_1, b_1), (t_2, b_2), \ldots, (t_n, b_n)\}: \keyby{T}{S}
    }

    \\

    \inference[Parallel]
    {
      b_1: S_1 \\
      b_2: S_2 \\
    }
    {
      (b_1, b_2): \parcomp{S_1}{S_2} \
    }

    \inference[Singleton]
    {
      t: T
    }
    {
      t: \singleton{T}
    }

    \inference[Empty]
    {
      \;
    }
    {
      []: \empstream{}
    }
\end{mathpar}

\subsubsection{Linearizations}

Linearizations are just sequences of events, rather than batches.
They have the following form:
\[
  L ::= [t_1: T_1, t_2: T_2, t_3: T_3, \ldots, t_n: T_n]
\]
where $T_i$ are base types; i.e. each element of the sequence can be
a different base type.
Linearizations support concatenation, $\cdot$, and the interleaving relation
$\texttt{interleave}(l, l_1, l_2)$.
These are typed using the following typing judgments:

\begin{mathpar}
    \inference[Synchronization]
    {
      t_i: T \\
      l_i: S
    }
    {
      l_0 \cdot [t_1] \cdot l_1 \cdot [t_2] \cdots [t_m] \cdot [l_m]: \hier{T}{S}
    }

    \\

    % TODO
    % \inference[PartitionBy]
    % {
    %   l_i:
    %   t_i: T \\
    %   t_i \ne t_j \text{ for } i \ne j \\
    %   b_i: S
    % }
    % {
    %   \{(t_1, b_1), (t_2, b_2), \ldots, (t_n, b_n)\}: \keyby{T}{S}
    % }

    \\

    \inference[Parallel]
    {
      \texttt{interleave}(l, l_1, l_2) \\
      l_1: S_1 \\
      l_2: S_2 \\
    }
    {
      l: \parcomp{S_1}{S_2}
    }

    \\

    \inference[Singleton]
    {
      t: T
    }
    {
      [t]: \singleton{T}
    }

    \inference[Empty]
    {
      \;
    }
    {
      []: \empstream{}
    }
\end{mathpar}
