\section{Syntax and Semantics}

This section lays the groundwork for the rest of the technical content of this dissertation: we present our core programmming language for distributed streaming applications. The language is built over a type system for streams called \emph{synchronization schemas}~\citeMain{pods21}, which evolved from earlier work on \emph{data-trace types}~\citeMain{festschrift18,pldi19}. a library of high-level language constructs over typed streams called \emph{SQREL}, and composition rules for composing language constructs.
% dummy citation to please bibtex -- TODO remove
\cite{StreamQRE}

\subsection{Syntax}

\subsubsection{Stream Types}

This definition differs from the stream types in \citeMain{pods21} in a few ways: (1) we don't assume the base types of events are headers (tuples); (2) the synchronization markers are elements of a single base type, not a set of headers; (3) we add the empty stream case, the singleton case, and the add-field case.

\begin{definition}
Let $T$ denote a base type in the following grammar.
A \emph{stream type} is a type defined syntactically by the following grammar:
\[
  S \quad ::= \quad
    \hier{T}{S} \mid
    \parcomp{S}{S} \mid
    \keyby{T}{S} \mid
    \singleton{T} \mid
    \empstream{}
\]
\end{definition}

We also have the following abbreviations:
\[
  \relleaf{T} := \keyby{T}{\singleton{\unittype{}}}
\]
where $\unittype{}$ denotes the unit type, and
\[
  \seqleaf{T} := \hier{T}{\empstream{}}.
\]

\subsubsection{Batch syntax (concrete stream instances)}

The following syntax defines concrete stream instances for each of the
stream types.
These are ``batch'' data.
To define a concrete stream instance, one either defines a pair, a sequence, or a bag (unordered set).
\[
  B \quad ::= \quad
    (B, B) \mid
    [B, B, \ldots, B] \mid
    \{B, B, \ldots, B\} \mid
    t: T \mid
    \unittype{}
\]

These are typed using the following typing rules:

\begin{mathpar}
    \inference[Synchronization]
    {
      t_i: T \\
      b_i: S
    }
    {
      [b_0, t_1, b_1, t_2, b_2, \ldots, t_m, b_m]: \hier{T}{S}
    }

    \\

    \inference[Parallel]
    {
      b_1: S_1 \\
      b_2: S_2 \\
    }
    {
      (b_1, b_2): \parcomp{S_1}{S_2} \
    }

    \inference[PartitionBy]
    {
      t_i: T \\
      t_i \ne t_j \text{ for } i \ne j \\
      b_i: S
    }
    {
      \{(t_1, b_1), \ldots, (t_n, b_n)\}: \keyby{T}{S}
    }

    \\

    \inference[Singleton]
    {
      t: T
    }
    {
      t: \singleton{T}
    }

    \inference[Empty]
    {
      \;\;
    }
    {
      \unittype: \empstream{}
    }
\end{mathpar}
