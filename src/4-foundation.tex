\section{A Foundation for Streams}
\headerblock{
  \headerquote{Almost every problem that you come across is befuddled with all kinds of extraneous data of one sort or another; and if you can bring this problem down into the main issues, you can see more clearly what youâ€™re trying to do.}{Claude Shannon}

  \headerbreak{}

  \headerimage{img/xkcd-standards.png}
}
\label{sec:foundation}

% I am very seldom interested in applications. I am more interested in the elegance of a problem. Is it a good problem, an interesting problem?
% Claude Shannon

% This section lays the groundwork for the rest of the technical content of this dissertation: we present our core programmming language for distributed streaming applications. The language is built over a type system for streams called \emph{synchronization schemas}~\citeMain{pods21}, which evolved from earlier work on \emph{data-trace types}~\citeMain{festschrift18,pldi19}. a library of high-level language constructs over typed streams called \emph{SQREL}, and composition rules for composing language constructs.

\subsection{Stream Types}

% This definition differs from the stream types in \citeMain{pods21} in a few ways: (1) we don't assume the base types of events are headers (tuples); (2) the synchronization markers are elements of a single base type, not a set of headers; (3) we add the empty stream case, the singleton case, and the add-field case.

\begin{definition}
Let $T$ denote a base type in the following grammar.
A \emph{stream type} is a type defined syntactically by the following grammar:
\[
  S \quad ::= \quad
    \hier{T}{S} \mid
    \parcomp{S}{S} \mid
    \keyby{T}{S} \mid
    \singleton{T} \mid
    \empstream{}
\]
\end{definition}

We also have the following abbreviations:
\[
  \relleaf{T} := \keyby{T}{\singleton{\unittype{}}}
\]
where $\unittype{}$ denotes the unit type, and
\[
  \seqleaf{T} := \hier{T}{\empstream{}}.
\]

\subsection{Streams as structured data}

The following syntax defines concrete \emph{structured} stream instances for each of the
stream types, which we call \emph{batches} because they represent data
collected into a static bundle.% TODO thank Joe for this.
To define a concrete stream instance, one either defines a pair, a sequence, or a bag (unordered set).
\[
  B \quad ::= \quad
    (B, B) \mid
    [B, B, \ldots, B] \mid
    \{B, B, \ldots, B\} \mid
    t: T
\]

These are typed using the following typing rules:

\begin{mathpar}
    \inference[Synchronization]
    {
      t_i: T \\
      \batchtype{b_i}{S}
    }
    {
      \batchtype{[b_0, t_1, b_1, t_2, b_2, \ldots, t_m, b_m]}{\hier{T}{S}}
    }

    \\

    \inference[Parallel]
    {
      \batchtype{b_1}{S_1} \\
      \batchtype{b_2}{S_2} \\
    }
    {
      \batchtype{(b_1, b_2)}{\parcomp{S_1}{S_2}}
    }

    \\

    \inference[PartitionBy]
    {
      t_i: T \\
      t_i \ne t_j \text{ for } i \ne j \\
      \batchtype{b_i}{S}
    }
    {
      \batchtype{\{(t_1, b_1), (t_2, b_2), \ldots, (t_n, b_n)\}}{\keyby{T}{S}}
    }

    \\

    \inference[Singleton]
    {
      t: T
    }
    {
      \batchtype{t}{\singleton{T}}
    }

    \inference[Empty]
    {
      \;
    }
    {
      \batchtype{[]}{\empstream{}}
    }
\end{mathpar}

\subsection{Streams as linear sequences of events}

\subsubsection{Events}

Events can be either base types are tuples.
Tuples are needed because if $K_1, \ldots, K_n$ are types of keys and $T$ is a payload type,
an event is a tuple of an element of each key and an element of the payload.
Here is a grammar for events:
\[
  E \quad ::= \quad (E, E) \mid t: T
\]

We can also talk about events specific to a particular stream type:
$\eventtype{e}{S}$ means that $e$ is a valid event for a stream type $S$.
Notice that there are no rules for $\eventtype{t}{\empstream{}}$ -- there are no events of the empty stream type.

\begin{mathpar}
    \inference[Synch-1]
    {
      e: T
    }
    {
      \eventtype{e}{\hier{T}{S}}
    }

    \inference[Synch-2]
    {
      \eventtype{e}{S}
    }
    {
      \eventtype{e}{\hier{T}{S}}
    }
    \\

    \inference[Par-1]
    {
      \eventtype{e}{S_1}
    }
    {
      \eventtype{e}{\parcomp{S_1}{S_2}}
    }

    \inference[Par-2]
    {
      \eventtype{e}{S_2}
    }
    {
      \eventtype{e}{\parcomp{S_1}{S_2}}
    }

    \\

    \inference[PartitionBy]
    {
      k: K \\
      \eventtype{e}{S}
    }
    {
      \eventtype{(k, e)}{\keyby{K}{S}}
    }

    \inference[Singleton]
    {
      e: T
    }
    {
      \eventtype{e}{\singleton{T}}
    }
\end{mathpar}

\subsubsection{Linearizations}

A \emph{linearization} is a sequence of events:
\[
  L \quad ::= \quad [E, E, \ldots, E]
\]
Notice that each event in the sequence may be different (they may even all have different types).
Linearizations support the operations of concatenation ($\cdot$), the interleaving relation
$\texttt{interleave}(l; l_1, l_2, \ldots)$,
and the element-wise product: for $t: E$ and $e_i: E$,
\[
  t \times [e_1, e_2, \ldots, e_n] := [(t, e_1), (t, e_2), \ldots, (t, e_n).
\]

Linearizations are typed using the following typing judgments:
\begin{mathpar}
    \inference[Synchronization]
    {
      t_i: T \\
      \lintype{l_i}{S} \\
      l = l_0 \cdot [t_1] \cdot l_1 \cdot [t_2] \cdots [t_m] \cdot l_m
    }
    {
      \lintype{l}{\hier{T}{S}}
    }

    \\

    \inference[PartitionBy]
    {
      k_i: T \\
      \lintype{l_i}{S} \\
      l_i \text{ nonempty} \\
      \texttt{interleave}(l; k_1 \times l_1, k_2 \times l_2, \ldots, k_n \times l_n)
    }
    {
      \lintype{l}{\keyby{T}{S}}
    }

    \\

    \inference[Parallel]
    {
      \texttt{interleave}(l; l_1, l_2) \\
      \lintype{l_1}{S_1} \\
      \lintype{l_2}{S_2} \\
    }
    {
      \lintype{l}{\parcomp{S_1}{S_2}}
    }

    \\

    \inference[Singleton]
    {
      t: T
    }
    {
      \lintype{[t]}{\singleton{T}}
    }

    \inference[Empty]
    {
      \;
    }
    {
      \lintype{[]}{\empstream{}}
    }
\end{mathpar}

\begin{proposition}
Let $S$ be a stream that doesn't use the singleton construct $\singleton{T}$.
Linearizations are the same as sequences of events:
for any stream type $S$ and sequence $l = [e_1, e_2, \ldots, e_n]$,
$\lintype{l}{S}$ iff $\eventtype{e_i}{S}$ for all $i$.
\end{proposition}

% TODO (bring content from sec5):
% - correspondence between linearizations and batches
%   - every linearization corresponds to a unique batch
%   - every batch can be linearized in at least one way (but maybe more)
% - empty stream (the batch corresponding to the empty linearization)

\subsection{Streams as traces}
% Mazurkiewicz

From the stream type $S$ we can derive not just a type fore vents
$\eventtype{e}{S}$, but a binary relation on $\eventtype{e_1, e_2}{S}$
called the \emph{dependence relation} $e_1 D e_2$.

\subsection{Streams as labeled posets}

\subsection{Incrementality}

\subsubsection{Generators}

Batches and linearizations represent static views of an entire stream, bundled up as one object. A generator is a way to define a stream \emph{incrementally} in a more true-to-life fashion:
\[
\inference[Generator]
{
  \texttt{State}: \texttt{Type} \\
  f: \texttt{State} \to \texttt{Option<}\texttt{Event}(S) \times \texttt{State>}
}
{
  \texttt{Generator}(f): S
}
\]

\subsection{Stream operators}

\subsection{Historical Notes}
